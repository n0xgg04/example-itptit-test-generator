"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
const datatypes_1 = __importDefault(require("./src/enums/datatypes"));
const lodash_1 = __importDefault(require("lodash"));
const validator_1 = __importDefault(require("./src/utils/validator"));
const output_generator_by_datatype_1 = __importDefault(require("./src/utils/output-generator-by-datatype"));
const effect_1 = __importDefault(require("./src/enums/effect"));
/**
 * Generate function
 * @param template - Class Template
 */
function generate(template) {
    const testCaseInstance = new template();
    const resultTemplate = testCaseInstance.template;
    const variables = Object.getOwnPropertyNames(testCaseInstance);
    variables.forEach((v) => {
        const reflectData = Reflect.getMetadata(`datatype:${v}`, testCaseInstance);
        const propsDes = Object.getOwnPropertyDescriptor(testCaseInstance, v);
        if (Reflect.hasMetadata(`datatype:${v}`, testCaseInstance)) {
            switch (reflectData.type) {
                case datatypes_1.default.Int:
                    Object.defineProperty(testCaseInstance, v, {
                        ...propsDes,
                        value: lodash_1.default.random(reflectData.min, reflectData.max, false)
                    });
                    break;
                case datatypes_1.default.NumberArray:
                    let elements_total = reflectData.element;
                    elements_total = (0, validator_1.default)(elements_total, testCaseInstance);
                    const data = lodash_1.default.times(elements_total).map(() => lodash_1.default.random(reflectData.min, reflectData.max, false));
                    Object.defineProperty(testCaseInstance, v, {
                        ...propsDes,
                        value: data
                    });
                    break;
            }
        }
    });
    let result = resultTemplate;
    //! Render
    variables.forEach((v) => {
        if (!Reflect.hasMetadata(`datatype:${v}`, testCaseInstance))
            return;
        result = result.replaceAll("$" + v, lodash_1.default.trimStart((0, output_generator_by_datatype_1.default)(testCaseInstance[v], Reflect.getMetadata(`datatype:${v}`, testCaseInstance).type)));
    });
    const effectMethod = Reflect.hasMetadata("effect", testCaseInstance)
        ? Reflect.getMetadata("effect", testCaseInstance)
        : [];
    effectMethod.forEach((v) => {
        const effectList = Reflect.getMetadata(`effect:${v}`, testCaseInstance);
        if (effectList.includes(effect_1.default.Loop)) {
            let res = "";
            const loopTime = (0, validator_1.default)(Reflect.getMetadata(`effect:${v}:time`, testCaseInstance), testCaseInstance);
            lodash_1.default.times(loopTime).map((i) => {
                const append = testCaseInstance[v]();
                if (i != 0)
                    res += `\n`;
                res += `${append}`;
            });
            result = result.replaceAll("$" + v, res);
        }
    });
    return lodash_1.default.trim(result);
}
exports.generate = generate;
